<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>brack3t</title><link href="http://brack3t.com" rel="alternate"></link><link href="http://brack3t.com/feeds/all-en.atom.xml" rel="self"></link><id>http://brack3t.com</id><updated>2012-03-02T12:52:47Z</updated><entry><title>Our Custom Mixins</title><link href="http://brack3t.com/our-custom-mixins.html" rel="alternate"></link><updated>2012-03-02T12:52:47Z</updated><author><name>Chris</name></author><id>tag:brack3t.com,2012-03-02:/our-custom-mixins.html/</id><summary type="html">&lt;p&gt;&lt;strong&gt;UPDATE&lt;/strong&gt;: We've released a &lt;a class="reference external" href="https://github.com/brack3t/django-braces"&gt;Github repo&lt;/a&gt; and a &lt;a class="reference external" href="http://pypi.python.org/pypi/braces/0.1.0"&gt;PyPI package&lt;/a&gt; with our mixins. Feel free to fork and submit new ones through a pull-request.&lt;/p&gt;
&lt;p&gt;Let's just start out and say it, &lt;strong&gt;Class Based Views&lt;/strong&gt;. Ooohhhh. Unfortunately the topic of class based views is
thought of as somewhat of a dark art in the Django community. It doesn't help that the documentation is still
lacking but I find a lot of people, especially on &lt;a class="reference external" href="http://reddit.com/r/django"&gt;Reddit&lt;/a&gt;, refuse to use them. For whatever reason, it's a hard
pill for some to swallow.&lt;/p&gt;
&lt;p&gt;Before DjangoCon 2011, we started playing with class-based views. At first they seemed like a nightmare and without
decent docs, we got frustrated really quickly. Skip forward to today and I can't imagine writing old function-based
views again. Some argue that the &lt;tt class="docutils literal"&gt;generic views&lt;/tt&gt; are only for generic applications and that, somehow, their work is far too
custom and complex to be handled in a generic class-based view. Based on my experience, 99% of the time, they would be wrong.&lt;/p&gt;
&lt;p&gt;We plan on covering generic class-based views extensively with &lt;a class="reference external" href="http://gettingstartedwithdjango.com"&gt;GSWD&lt;/a&gt;. Today, I'd like to share some mixins we
have cooked up, on a rather large client project, that have helped us out tremendously.&lt;/p&gt;
&lt;p&gt;For those of you not familiar with decorating class-based views, check out the Django documentation on
&lt;a class="reference external" href="https://docs.djangoproject.com/en/dev/topics/class-based-views/#decorating-the-class"&gt;decorating the class&lt;/a&gt;. We don't like the idea of doing decoration in Django's &lt;tt class="docutils literal"&gt;urls.py&lt;/tt&gt; or creating
another instance variable just to hold a decorated class. To us, mixins feel more Pythonic.&lt;/p&gt;
&lt;div class="contents well topic" id="mixins"&gt;
&lt;p class="topic-title first"&gt;Mixins&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;a class="reference internal" href="#loginrequiredmixin" id="id1"&gt;LoginRequiredMixin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#permissionrequiredmixin" id="id2"&gt;PermissionRequiredMixin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#superuserrequiredmixin" id="id3"&gt;SuperuserRequiredMixin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#userformkwargsmixin" id="id4"&gt;UserFormKwargsMixin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#userkwargmodelformmixin" id="id5"&gt;UserKwargModelFormMixin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#successurlredirectlistmixin" id="id6"&gt;SuccessURLRedirectListMixin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#setheadlinemixin" id="id7"&gt;SetHeadlineMixin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class="reference internal" href="#conclusion" id="id8"&gt;Conclusion&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class="section" id="loginrequiredmixin"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id1"&gt;LoginRequiredMixin&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class LoginRequiredMixin(object):&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    View mixin which verifies that the user has authenticated.&lt;/span&gt;

&lt;span class="x"&gt;    NOTE:&lt;/span&gt;
&lt;span class="x"&gt;        This should be the left-most mixin of a view.&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="x"&gt;    @method_decorator(login_required)&lt;/span&gt;
&lt;span class="x"&gt;    def dispatch(self, *args, **kwargs):&lt;/span&gt;
&lt;span class="x"&gt;        return super(LoginRequiredMixin, self).dispatch(*args, **kwargs)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This mixin is rather simple and is generally the first inherited class in any of our views. If we don't have an authenticated user
there's no need to go any further. If you've used Django before you are probably familiar with the &lt;tt class="docutils literal"&gt;login_required&lt;/tt&gt; decorator.
All we are doing here is requiring a user to be authenticated to be able to get to this view.&lt;/p&gt;
&lt;p&gt;While this doesn't look like much, it frees us up from having to manually overload the dispatch method on every single view that
requires a user to be authenticated. If that's all that is needed on this view, we just saved 3 lines of code. Example usage below.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;from django.views.generic import TemplateView&lt;/span&gt;

&lt;span class="x"&gt;from myapp.mixins import LoginRequiredMixin&lt;/span&gt;


&lt;span class="x"&gt;class SomeSecretView(LoginRequiredMixin, TemplateView):&lt;/span&gt;
&lt;span class="x"&gt;    template_name = &amp;quot;path/to/template.html&amp;quot;&lt;/span&gt;

&lt;span class="x"&gt;    def get(self, request):&lt;/span&gt;
&lt;span class="x"&gt;        return self.render_to_response({})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="permissionrequiredmixin"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id2"&gt;PermissionRequiredMixin&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class PermissionRequiredMixin(object):&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    View mixin which verifies that the logged in user has the specified&lt;/span&gt;
&lt;span class="x"&gt;    permission.&lt;/span&gt;

&lt;span class="x"&gt;    Class Settings&lt;/span&gt;
&lt;span class="x"&gt;    `permission_required` - the permission to check for.&lt;/span&gt;
&lt;span class="x"&gt;    `login_url` - the login url of site&lt;/span&gt;
&lt;span class="x"&gt;    `redirect_field_name` - defaults to &amp;quot;next&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    `raise_exception` - defaults to False - raise 403 if set to True&lt;/span&gt;

&lt;span class="x"&gt;    Example Usage&lt;/span&gt;

&lt;span class="x"&gt;        class SomeView(PermissionRequiredMixin, ListView):&lt;/span&gt;
&lt;span class="x"&gt;            ...&lt;/span&gt;
&lt;span class="x"&gt;            # required&lt;/span&gt;
&lt;span class="x"&gt;            permission_required = &amp;quot;app.permission&amp;quot;&lt;/span&gt;

&lt;span class="x"&gt;            # optional&lt;/span&gt;
&lt;span class="x"&gt;            login_url = &amp;quot;/signup/&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;            redirect_field_name = &amp;quot;hollaback&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;            raise_exception = True&lt;/span&gt;
&lt;span class="x"&gt;            ...&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    login_url = settings.LOGIN_URL&lt;/span&gt;
&lt;span class="x"&gt;    permission_required = None&lt;/span&gt;
&lt;span class="x"&gt;    raise_exception = False&lt;/span&gt;
&lt;span class="x"&gt;    redirect_field_name = REDIRECT_FIELD_NAME&lt;/span&gt;

&lt;span class="x"&gt;    def dispatch(self, request, *args, **kwargs):&lt;/span&gt;
&lt;span class="x"&gt;        # Verify class settings&lt;/span&gt;
&lt;span class="x"&gt;        if self.permission_required == None or len(&lt;/span&gt;
&lt;span class="x"&gt;            self.permission_required.split(&amp;quot;.&amp;quot;)) != 2:&lt;/span&gt;
&lt;span class="x"&gt;            raise ImproperlyConfigured(&amp;quot;&amp;#39;PermissionRequiredMixin&amp;#39; requires &amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;                &amp;quot;&amp;#39;permission_required&amp;#39; attribute to be set.&amp;quot;)&lt;/span&gt;

&lt;span class="x"&gt;        has_permission = request.user.has_perm(self.permission_required)&lt;/span&gt;

&lt;span class="x"&gt;        if not has_permission:&lt;/span&gt;
&lt;span class="x"&gt;            if self.raise_exception:&lt;/span&gt;
&lt;span class="x"&gt;                return HttpResponseForbidden()&lt;/span&gt;
&lt;span class="x"&gt;            else:&lt;/span&gt;
&lt;span class="x"&gt;                path = urlquote(request.get_full_path())&lt;/span&gt;
&lt;span class="x"&gt;                tup = self.login_url, self.redirect_field_name, path&lt;/span&gt;
&lt;span class="x"&gt;                return HttpResponseRedirect(&amp;quot;%s?%s=%s&amp;quot; % tup)&lt;/span&gt;

&lt;span class="x"&gt;        return super(PermissionRequiredMixin, self).dispatch(&lt;/span&gt;
&lt;span class="x"&gt;            request, *args, **kwargs)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This mixin was originally written, I believe, by &lt;a class="reference external" href="https://github.com/danols"&gt;Daniel Sokolowski&lt;/a&gt; (&lt;a class="reference external" href="https://github.com/lukaszb/django-guardian/issues/48"&gt;code here&lt;/a&gt;).&lt;/p&gt;
&lt;p&gt;The permission required mixin has been very handy for our client's custom CMS. Again, rather than overloading the
dispatch method manually on every view that needs to check for the existence of a permission, we inherit this class
and set the &lt;tt class="docutils literal"&gt;permission_required&lt;/tt&gt; class attribute on our view. If you don't specify &lt;tt class="docutils literal"&gt;permission_required&lt;/tt&gt; on
your view, an &lt;tt class="docutils literal"&gt;ImproperlyConfigured&lt;/tt&gt; exception is raised reminding you that you haven't set it.&lt;/p&gt;
&lt;p&gt;The one limitation of this mixin is that it can &lt;strong&gt;only&lt;/strong&gt; accept a single permission. It would need to be modified to
handle more than one. We haven't needed that yet, so this has worked out well for us.&lt;/p&gt;
&lt;p&gt;In our normal use case for this mixin, &lt;tt class="docutils literal"&gt;LoginRequiredMixin&lt;/tt&gt; comes first, then the &lt;tt class="docutils literal"&gt;PermissionRequiredMixin&lt;/tt&gt;. If we
don't have an authenticated user, there is no sense in checking for any permissions.&lt;/p&gt;
&lt;blockquote&gt;
&lt;span class="label label-info"&gt;note&lt;/span&gt; If you are using Django's built in auth system, &lt;tt class="docutils literal"&gt;superusers&lt;/tt&gt; automatically have all permissions in your system.&lt;/blockquote&gt;
&lt;/div&gt;
&lt;div class="section" id="superuserrequiredmixin"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id3"&gt;SuperuserRequiredMixin&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class SuperuserRequiredMixin(object):&lt;/span&gt;
&lt;span class="x"&gt;    login_url = settings.LOGIN_URL&lt;/span&gt;
&lt;span class="x"&gt;    raise_exception = False&lt;/span&gt;
&lt;span class="x"&gt;    redirect_field_name = REDIRECT_FIELD_NAME&lt;/span&gt;

&lt;span class="x"&gt;    def dispatch(self, request, *args, **kwargs):&lt;/span&gt;
&lt;span class="x"&gt;        if not request.user.is_superuser:&lt;/span&gt;
&lt;span class="x"&gt;            if self.raise_exception:&lt;/span&gt;
&lt;span class="x"&gt;                return HttpResponseForbidden()&lt;/span&gt;
&lt;span class="x"&gt;            else:&lt;/span&gt;
&lt;span class="x"&gt;                path = urlquote(request.get_full_path())&lt;/span&gt;
&lt;span class="x"&gt;                tup = self.login_url, self.redirect_field_name, path&lt;/span&gt;
&lt;span class="x"&gt;                return HttpResponseRedirect(&amp;quot;%s?%s=%s&amp;quot; % tup)&lt;/span&gt;

&lt;span class="x"&gt;        return super(SuperuserRequiredMixin, self).dispatch(&lt;/span&gt;
&lt;span class="x"&gt;            request, *args, **kwargs)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Another permission-based mixin. This is specifically for requiring a user to be a superuser. Comes in handy for tools that only privileged
users should have access to.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="userformkwargsmixin"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id4"&gt;UserFormKwargsMixin&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class UserFormKwargsMixin(object):&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    CBV mixin which puts the user from the request into the form kwargs.&lt;/span&gt;
&lt;span class="x"&gt;    Note: Using this mixin requires you to pop the `user` kwarg&lt;/span&gt;
&lt;span class="x"&gt;    out of the dict in the super of your form&amp;#39;s `__init__`.&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    def get_form_kwargs(self, **kwargs):&lt;/span&gt;
&lt;span class="x"&gt;        kwargs = super(UserFormKwargsMixin, self).get_form_kwargs(**kwargs)&lt;/span&gt;
&lt;span class="x"&gt;        kwargs.update({&amp;quot;user&amp;quot;: self.request.user})&lt;/span&gt;
&lt;span class="x"&gt;        return kwargs&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In our clients CMS, we have a lot of form-based views that require a user to be passed in for permission-based form tools. For example,
only superusers can delete or disable certain objects. To custom tailor the form for users, we have to pass that user instance into the form
and based on their permission level, change certain fields or add specific options within the forms &lt;tt class="docutils literal"&gt;__init__&lt;/tt&gt; method.&lt;/p&gt;
&lt;p&gt;This mixin automates the process of overloading the &lt;tt class="docutils literal"&gt;get_form_kwargs&lt;/tt&gt; (this method is available in any generic view which handles a form) method
and stuffs the user instance into the form kwargs. We can then pop the user off in the form and do with it what we need. &lt;strong&gt;Always&lt;/strong&gt; remember
to pop the user from the kwargs before calling &lt;tt class="docutils literal"&gt;super&lt;/tt&gt; on your form, otherwise the form gets an unexpected keyword argument and everything
blows up. Example usage:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;from django.views.generic import CreateView&lt;/span&gt;

&lt;span class="x"&gt;from myapp.mixins import LoginRequiredMixin, UserFormKwargsMixin&lt;/span&gt;
&lt;span class="x"&gt;from next.example import UserForm&lt;/span&gt;


&lt;span class="x"&gt;class SomeSecretView(LoginRequiredMixin, UserFormKwargsMixin,&lt;/span&gt;
&lt;span class="x"&gt;    TemplateView):&lt;/span&gt;

&lt;span class="x"&gt;    form_class = UserForm&lt;/span&gt;
&lt;span class="x"&gt;    model = User&lt;/span&gt;
&lt;span class="x"&gt;    template_name = &amp;quot;path/to/template.html&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="userkwargmodelformmixin"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id5"&gt;UserKwargModelFormMixin&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class UserKwargModelFormMixin(object):&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    Generic model form mixin for popping user out of the kwargs and&lt;/span&gt;
&lt;span class="x"&gt;    attaching it to the instance.&lt;/span&gt;

&lt;span class="x"&gt;    This mixin must precede forms.ModelForm/forms.Form. The form is not&lt;/span&gt;
&lt;span class="x"&gt;    expecting these kwargs to be passed in, so they must be poppped off before&lt;/span&gt;
&lt;span class="x"&gt;    anything else is done.&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    def __init__(self, *args, **kwargs):&lt;/span&gt;
&lt;span class="x"&gt;        self.user = kwargs.pop(&amp;quot;user&amp;quot;, None)&lt;/span&gt;
&lt;span class="x"&gt;        super(UserKwargModelFormMixin, self).__init__(*args, **kwargs)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;UserKwargModelFormMixin&lt;/tt&gt; is a new form mixin we just implemented this week to go along with our &lt;tt class="docutils literal"&gt;UserFormKwargsMixin&lt;/tt&gt;.
This becomes the first inherited class of our forms that receive the user keyword argument. With this mixin, we have automated
the popping off of the keyword argument in our form and no longer have to do it manually on every form that works this way.
While this may be overkill for a weekend project, for us, it speeds up adding new features. Example usage:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class UserForm(UserKwargModelFormMixin, forms.ModelForm):&lt;/span&gt;
&lt;span class="x"&gt;    class Meta:&lt;/span&gt;
&lt;span class="x"&gt;        model = User&lt;/span&gt;

&lt;span class="x"&gt;    def __init__(self, *args, **kwargs):&lt;/span&gt;
&lt;span class="x"&gt;        super(UserForm, self).__init__(*args, **kwargs):&lt;/span&gt;

&lt;span class="x"&gt;        if not self.user.is_superuser:&lt;/span&gt;
&lt;span class="x"&gt;            del self.fields[&amp;quot;group&amp;quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="successurlredirectlistmixin"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id6"&gt;SuccessURLRedirectListMixin&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class SuccessURLRedirectListMixin(object):&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    Simple CBV mixin which sets the success url to the list view of&lt;/span&gt;
&lt;span class="x"&gt;    a given app. Set success_list_url as a class attribute of your&lt;/span&gt;
&lt;span class="x"&gt;    CBV and don&amp;#39;t worry about overloading the get_success_url.&lt;/span&gt;

&lt;span class="x"&gt;    This is only to be used for redirecting to a list page. If you need&lt;/span&gt;
&lt;span class="x"&gt;    to reverse the url with kwargs, this is not the mixin to use.&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    success_list_url = None&lt;/span&gt;

&lt;span class="x"&gt;    def get_success_url(self):&lt;/span&gt;
&lt;span class="x"&gt;        return reverse(self.success_list_url)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;SuccessURLRedirectListMixin&lt;/tt&gt; is a bit more tailored to how we handle &lt;a class="reference external" href="http://en.wikipedia.org/wiki/Create,_read,_update_and_delete"&gt;CRUD&lt;/a&gt; within our CMS. Our CMS's workflow, by design,
redirects the user to the &lt;tt class="docutils literal"&gt;ListView&lt;/tt&gt; for whatever model they are working with, whether they are creating a new instance, editing
an existing one or deleting one. Rather than having to override &lt;tt class="docutils literal"&gt;get_success_url&lt;/tt&gt; on every view, we simply use this mixin and pass it
a reversible route name. Example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;# urls.py&lt;/span&gt;
&lt;span class="x"&gt;url(r&amp;quot;^users/$&amp;quot;, UserListView.as_view(), name=&amp;quot;cms_users_list&amp;quot;),&lt;/span&gt;

&lt;span class="x"&gt;# views.py&lt;/span&gt;
&lt;span class="x"&gt;class UserCreateView(LoginRequiredMixin, PermissionRequiredMixin,&lt;/span&gt;
&lt;span class="x"&gt;    SuccessURLRedirectListMixin, CreateView):&lt;/span&gt;

&lt;span class="x"&gt;    form_class = UserForm&lt;/span&gt;
&lt;span class="x"&gt;    model = User&lt;/span&gt;
&lt;span class="x"&gt;    permission_required = &amp;quot;auth.add_user&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    success_list_url = &amp;quot;cms_users_list&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    ...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="setheadlinemixin"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id7"&gt;SetHeadlineMixin&lt;/a&gt;&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class SetHeadlineMixin(object):&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    Mixin allows you to set a static headline through a static property on the&lt;/span&gt;
&lt;span class="x"&gt;    class or programmatically by overloading the get_headline method.&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    headline = None&lt;/span&gt;

&lt;span class="x"&gt;    def get_context_data(self, **kwargs):&lt;/span&gt;
&lt;span class="x"&gt;        kwargs = super(SetHeadlineMixin, self).get_context_data(**kwargs)&lt;/span&gt;
&lt;span class="x"&gt;        kwargs.update({&amp;quot;headline&amp;quot;: self.get_headline()})&lt;/span&gt;
&lt;span class="x"&gt;        return kwargs&lt;/span&gt;

&lt;span class="x"&gt;    def get_headline(self):&lt;/span&gt;
&lt;span class="x"&gt;        if self.headline is None:&lt;/span&gt;
&lt;span class="x"&gt;            raise ImproperlyConfigured(u&amp;quot;%(cls)s is missing a headline. Define &amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;                u&amp;quot;%(cls)s.headline, or override &amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;                u&amp;quot;%(cls)s.get_headline().&amp;quot; % {&amp;quot;cls&amp;quot;: self.__class__.__name__&lt;/span&gt;
&lt;span class="x"&gt;            })&lt;/span&gt;
&lt;span class="x"&gt;        return self.headline&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;SetHeadlineMixin&lt;/tt&gt; is a newer edition to our client's CMS. It allows us to &lt;em&gt;statically&lt;/em&gt; or &lt;em&gt;programmatically&lt;/em&gt; set the headline of any
of our views. We like to write as few templates as possible, so a mixin like this helps us reuse generic templates. Its usage is amazingly
straightforward and works much like Django's built-in &lt;tt class="docutils literal"&gt;get_queryset&lt;/tt&gt; method. This mixin has two ways of being used.&lt;/p&gt;
&lt;div class="section" id="static-example"&gt;
&lt;h3&gt;Static Example&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class HeadlineView(SetHeadlineMixin, TemplateView):&lt;/span&gt;
&lt;span class="x"&gt;    headline = &amp;quot;This is our headline&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    template_name = &amp;quot;path/to/template.html&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="dynamic-example"&gt;
&lt;h3&gt;Dynamic Example&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;from datetime import date&lt;/span&gt;


&lt;span class="x"&gt;class HeadlineView(SetHeadlineMixin, TemplateView):&lt;/span&gt;
&lt;span class="x"&gt;    template_name = &amp;quot;path/to/template.html&amp;quot;&lt;/span&gt;

&lt;span class="x"&gt;    def get_headline(self):&lt;/span&gt;
&lt;span class="x"&gt;        return u&amp;quot;This is our headline for %s&amp;quot; % date.today().isoformat()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In both usages, in the template, just print out &lt;tt class="docutils literal"&gt;{{ headline }}&lt;/tt&gt; to show the generated headline.&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class="section" id="conclusion"&gt;
&lt;h2&gt;&lt;a class="toc-backref" href="#id8"&gt;Conclusion&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Hopefully we've inspired you to use class-based views and custom mixins in your own projects or, at the very least, give class-based views another look.
Writing custom mixins helps to alleviate pain points in your project and make it faster to create new features, at least is has for us. If you have
any questions, leave a comment or hit us up on Twitter.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="django"></category><category term="CBVs"></category></entry><entry><title></title><link href="http://brack3t.com/.html" rel="alternate"></link><updated>2012-03-02T12:19:05Z</updated><author><name>Brack3t, aka Kenneth Love and Chris Jones</name></author><id>tag:brack3t.com,2012-03-02:/.html/</id><summary type="html"></summary></entry><entry><title>Generic Layouts in Crispy Forms</title><link href="http://brack3t.com/generic-layouts-in-crispy-forms.html" rel="alternate"></link><updated>2012-02-29T18:11:15Z</updated><author><name>Kenneth</name></author><id>tag:brack3t.com,2012-02-29:/generic-layouts-in-crispy-forms.html/</id><summary type="html">&lt;p&gt;Just a quick tip and sanity check, today, about something I ran into with &lt;a class="reference external" href="https://github.com/maraujop/django-crispy-forms"&gt;django-crispy-forms&lt;/a&gt;, the awesome new form library from Miguel Araujo.&lt;/p&gt;
&lt;p&gt;This morning, I converted the project we've been building for a client (currently some 1,700 or so files, counting templates, CSS, and icons) from &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;django-uni-form&lt;/span&gt;&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;django-crispy-forms&lt;/span&gt;&lt;/tt&gt;. It's a pretty painless
transition, actually. Just do some find-and-replace across your files, basically changing any instance of &lt;tt class="docutils literal"&gt;uni-&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;crispy-&lt;/tt&gt; (well, and &lt;tt class="docutils literal"&gt;form&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;forms&lt;/tt&gt;), and you're good to go. Then, however, I wanted to
convert two large forms that we have, which share 90% of their fields, to using the sharable &lt;tt class="docutils literal"&gt;Layout&lt;/tt&gt; objects that &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;django-crispy-forms&lt;/span&gt;&lt;/tt&gt; gives us.&lt;/p&gt;
&lt;p&gt;Basically, the forms looked like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class FirstForm(GenericAppFormForTheExample):&lt;/span&gt;
&lt;span class="x"&gt;    ...&lt;/span&gt;

&lt;span class="x"&gt;    def __init__(self, *args, **kwargs):&lt;/span&gt;
&lt;span class="x"&gt;        ...&lt;/span&gt;
&lt;span class="x"&gt;        self.helper = FormHelper()&lt;/span&gt;
&lt;span class="x"&gt;        self.helper.layout = Layout(&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;field1&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;field2&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;special-field&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;            [field3 through field20]&lt;/span&gt;

&lt;span class="x"&gt;class SecondForm(GenericAppFormForTheExample):&lt;/span&gt;
&lt;span class="x"&gt;    ...&lt;/span&gt;

&lt;span class="x"&gt;    def __init__(self, *args, **kwargs):&lt;/span&gt;
&lt;span class="x"&gt;        ...&lt;/span&gt;
&lt;span class="x"&gt;        self.helper = FormHelper()&lt;/span&gt;
&lt;span class="x"&gt;        self.helper.layout = Layout(&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;field1&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;field2&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;special-field2&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;            [field3 thorugh field20]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Obviously that was a lot of repetition that we could cut out now that these inheritable layouts exist. By the way, I'm pretty sure this would have been possible in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;django-uni-form&lt;/span&gt;&lt;/tt&gt; but likely not as friendly.&lt;/p&gt;
&lt;p&gt;First I started off by creating the shared resources. I made two of them since our special fields come in the middle of our layouts.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;form_intro_layout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Layout&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;field1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;field2&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;form_common_layout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Layout&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;field3&lt;/span&gt; &lt;span class="n"&gt;through&lt;/span&gt; &lt;span class="n"&gt;field20&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And I added them each into my forms. I'm only going to show one form but you'll get the idea.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;self.form_intro_layout = form_intro_layout&lt;/span&gt;
&lt;span class="x"&gt;self.form_intro_layout.insert(-1, &amp;quot;special-field&amp;quot;)&lt;/span&gt;

&lt;span class="x"&gt;self.helper.layout = Layout(&lt;/span&gt;
&lt;span class="x"&gt;    self.form_intro_layout,&lt;/span&gt;
&lt;span class="x"&gt;    form_common_layout&lt;/span&gt;
&lt;span class="x"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And, display-wise, it worked fine. This is, ideally, exactly what you do to extend these layouts. &lt;strong&gt;But&lt;/strong&gt;, this causes problems in testing.&lt;/p&gt;
&lt;p&gt;We test all of our views, models, and forms. The form tests passed fine, but some of the view tests were throwing up warnings about fields being referenced more than once and, for example, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;special-field2&lt;/span&gt;&lt;/tt&gt; missing
from &lt;tt class="docutils literal"&gt;FirstForm&lt;/tt&gt;. Obviously something was up with the inheritance and with how I was instantiating objects.&lt;/p&gt;
&lt;p&gt;My next step was to stop using &lt;tt class="docutils literal"&gt;self&lt;/tt&gt; on the instance-specific versions of the generic layouts and just give them a local name like &lt;tt class="docutils literal"&gt;standard_intro_layout&lt;/tt&gt; (the &lt;tt class="docutils literal"&gt;standard&lt;/tt&gt; name makes more sense internally and its
meaning isn't important for this example), but that didn't stop the errors. It did, however, still work fine visually.&lt;/p&gt;
&lt;p&gt;I tried using a &lt;tt class="docutils literal"&gt;.copy()&lt;/tt&gt; method on the layout, but that doesn't exist. So I turned to the &lt;tt class="docutils literal"&gt;copy&lt;/tt&gt; module of Python, specifically the &lt;tt class="docutils literal"&gt;deepcopy&lt;/tt&gt; method. I tried with just the standard &lt;tt class="docutils literal"&gt;copy&lt;/tt&gt; method, but it had
the same effect of working visually, but throwing warnings on tests.&lt;/p&gt;
&lt;p&gt;The new version looked like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;from copy import deepcopy&lt;/span&gt;

&lt;span class="x"&gt;standard_intro_layout = deepcopy(form_intro_layout)&lt;/span&gt;
&lt;span class="x"&gt;standard_intro_layout.insert(-1, &amp;quot;special-field&amp;quot;)&lt;/span&gt;
&lt;span class="x"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That works perfectly! It still appears the same visually, like all the methods have, and it also quiets the tests so they pass without warnings.&lt;/p&gt;
&lt;p&gt;Unless someone knows of a reason I shouldn't use &lt;tt class="docutils literal"&gt;deepcopy&lt;/tt&gt;, this seems to be the way to solve this problem. I'm also not sure if it was the &lt;tt class="docutils literal"&gt;self&lt;/tt&gt; (which I doubt, since I removed it and the warnings still
happened), or the fact that both forms extend the same abstract form, or some other variable that led to the problem. Regardless, I'm happy to have solved it.&lt;/p&gt;
</summary><category term="django"></category><category term="django-crispy-forms"></category><category term="tip"></category></entry><entry><title>Change Request Workflow</title><link href="http://brack3t.com/change-request-workflow.html" rel="alternate"></link><updated>2012-02-26T11:01:00Z</updated><author><name>Kenneth</name></author><id>tag:brack3t.com,2012-02-26:/change-request-workflow.html/</id><summary type="html">&lt;p&gt;Before we start, let me explain a bit about what the app we're covering here is. It's a geo-spatial database, basically, of
Points of Interest (POIs) for housing communities that we developed for a client of ours (or, rather, are still developing).
Users and editors can both enter Points into the database, which is PostgreSQL with PostGIS, and then they can be associated
with any community.  Obviosuly, though, that leads to the problem of Community A editing a POI and Community B showing that data
without their knowledge, so we'd like to have an editor look at the changes first. That's the need that lead to our workflow.&lt;/p&gt;
&lt;div class="section" id="models"&gt;
&lt;h2&gt;Models&lt;/h2&gt;
&lt;p&gt;First, let's start with the models.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class POIAbstract(LumberjackModel, models.Model):&lt;/span&gt;
&lt;span class="x"&gt;    category = models.ForeignKey(Category, related_name=&amp;quot;%(class)s_points&amp;quot;)&lt;/span&gt;
&lt;span class="x"&gt;    name = models.CharField(max_length=255)&lt;/span&gt;
&lt;span class="x"&gt;    address = models.CharField(max_length=255)&lt;/span&gt;
&lt;span class="x"&gt;    address2 = models.CharField(max_length=255, blank=True)&lt;/span&gt;
&lt;span class="x"&gt;    city = models.CharField(max_length=100)&lt;/span&gt;
&lt;span class="x"&gt;    state = USPostalCodeField()&lt;/span&gt;
&lt;span class="x"&gt;    zip_code = models.CharField(max_length=10)&lt;/span&gt;
&lt;span class="x"&gt;    phone = PhoneNumberField(blank=True, default=&amp;quot;&amp;quot;)&lt;/span&gt;
&lt;span class="x"&gt;    url = models.URLField(blank=True, default=&amp;quot;&amp;quot;)&lt;/span&gt;
&lt;span class="x"&gt;    point = models.PointField(blank=True, null=True, editable=False)&lt;/span&gt;
&lt;span class="x"&gt;    objects = models.GeoManager()&lt;/span&gt;

&lt;span class="x"&gt;    class Meta:&lt;/span&gt;
&lt;span class="x"&gt;        abstract = True&lt;/span&gt;

&lt;span class="x"&gt;    def __unicode__(self):&lt;/span&gt;
&lt;span class="x"&gt;        return self.name&lt;/span&gt;

&lt;span class="x"&gt;    @property&lt;/span&gt;
&lt;span class="x"&gt;    def coords(self):&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        Return tuple of lat,lng&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        if self.point:&lt;/span&gt;
&lt;span class="x"&gt;            return (self.point.get_coords()[1], self.point.get_coords()[0])&lt;/span&gt;
&lt;span class="x"&gt;        return (None, None)&lt;/span&gt;

&lt;span class="x"&gt;    @property&lt;/span&gt;
&lt;span class="x"&gt;    def full_address(self):&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        Return a string of the full address&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        addresses = [self.address, self.address2, self.city, self.state,&lt;/span&gt;
&lt;span class="x"&gt;            self.zip_code, &amp;quot;USA&amp;quot;]&lt;/span&gt;
&lt;span class="x"&gt;        return &amp;quot;, &amp;quot;.join(filter(lambda x: len(x) &amp;gt; 0, addresses))&lt;/span&gt;


&lt;span class="x"&gt;class POI(POIAbstract):&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    Points of Interest model.&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    pass&lt;/span&gt;


&lt;span class="x"&gt;class POIChange(POIAbstract):&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    Holds proposed changes to POIs&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    STATUS_CHOICES = (&lt;/span&gt;
&lt;span class="x"&gt;        (0, &amp;quot;Pending&amp;quot;),&lt;/span&gt;
&lt;span class="x"&gt;        (1, &amp;quot;Denied&amp;quot;),&lt;/span&gt;
&lt;span class="x"&gt;        (2, &amp;quot;Approved&amp;quot;)&lt;/span&gt;
&lt;span class="x"&gt;    )&lt;/span&gt;

&lt;span class="x"&gt;    poi = models.ForeignKey(POI, related_name=&amp;quot;changes&amp;quot;)&lt;/span&gt;
&lt;span class="x"&gt;    user = models.ForeignKey(User, related_name=&amp;quot;poi_changes&amp;quot;)&lt;/span&gt;
&lt;span class="x"&gt;    submitted_on = models.DateField(auto_now_add=True, editable=False)&lt;/span&gt;
&lt;span class="x"&gt;    approved_by = models.ForeignKey(User, related_name=&amp;quot;poi_approvals&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;        blank=True, null=True, editable=False)&lt;/span&gt;
&lt;span class="x"&gt;    approved_on = models.DateField(blank=True, null=True, editable=False)&lt;/span&gt;
&lt;span class="x"&gt;    status = models.PositiveSmallIntegerField(choices=STATUS_CHOICES,&lt;/span&gt;
&lt;span class="x"&gt;        default=0, editable=False)&lt;/span&gt;

&lt;span class="x"&gt;    class Meta:&lt;/span&gt;
&lt;span class="x"&gt;        ordering = [&amp;quot;status&amp;quot;, &amp;quot;-submitted_on&amp;quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, there's not really anything too interesting about the models. We have an abstract model that we inherit both of our other models from. The approved record model is just the abstract model without it's
&lt;tt class="docutils literal"&gt;abstract = True&lt;/tt&gt; setting. The change model, though, adds a few fields.&lt;/p&gt;
&lt;p&gt;First we point to the record we're changing. Then we hold on to the user that submitted the changes, and the time of the request. We also want to have a record of who approved/denied it and when. And, of course, we
need to know what the status of the change is. That'll let us change our minds later on.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="forms"&gt;
&lt;h2&gt;Forms&lt;/h2&gt;
&lt;p&gt;We usually end up building forms after we build models (more on this when we finish &lt;a class="reference external" href="http://gettingstartedwithdjango.com"&gt;GSWD&lt;/a&gt;), so let's look at them next.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class POIForm(forms.ModelForm):&lt;/span&gt;
&lt;span class="x"&gt;    latitude = forms.FloatField(required=False,&lt;/span&gt;
&lt;span class="x"&gt;        widget=forms.HiddenInput())&lt;/span&gt;
&lt;span class="x"&gt;    longitude = forms.FloatField(required=False,&lt;/span&gt;
&lt;span class="x"&gt;        widget=forms.HiddenInput())&lt;/span&gt;

&lt;span class="x"&gt;    class Meta:&lt;/span&gt;
&lt;span class="x"&gt;        model = POI&lt;/span&gt;


&lt;span class="x"&gt;class POIChangeForm(forms.ModelForm):&lt;/span&gt;
&lt;span class="x"&gt;    latitude = forms.FloatField(required=False,&lt;/span&gt;
&lt;span class="x"&gt;        widget=forms.HiddenInput())&lt;/span&gt;
&lt;span class="x"&gt;    longitude = forms.FloatField(required=False,&lt;/span&gt;
&lt;span class="x"&gt;        widget=forms.HiddenInput())&lt;/span&gt;

&lt;span class="x"&gt;    class Meta:&lt;/span&gt;
&lt;span class="x"&gt;        model = POIChange&lt;/span&gt;
&lt;span class="x"&gt;        widgets = {&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;poi&amp;quot;: forms.HiddenInput(),&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;user&amp;quot;: forms.HiddenInput()&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I've left out some of the boilerplate and &lt;tt class="docutils literal"&gt;Layout&lt;/tt&gt; bits from &lt;a class="reference external" href="https://github.com/pydanny/django-uni-form"&gt;django-uni-form&lt;/a&gt; (we haven't upgraded to &lt;a class="reference external" href="https://github.com/maraujop/django-crispy-forms"&gt;django-crispy-forms&lt;/a&gt; yet) but you get the general idea. Honestly, we could have made the second form inherit from
the first and saved a bit of typing/space, but I guess we missed that. Both forms, ultimately, show the same thing. The latter form, though, holds onto a few extra fields that we need and that we'll set in the view.&lt;/p&gt;
&lt;p&gt;Speaking of views, let's check them out.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="views"&gt;
&lt;h2&gt;Views&lt;/h2&gt;
&lt;p&gt;We're not going to look at the view that creates the original POI. It's just a standard
&lt;tt class="docutils literal"&gt;CreateView&lt;/tt&gt; that specifies our &lt;tt class="docutils literal"&gt;POIForm&lt;/tt&gt; as the &lt;tt class="docutils literal"&gt;form_class&lt;/tt&gt;. We have a couple of handy
mixins on the views that let us control permissions and redirects, but we'll talk about them in
another blog post.&lt;/p&gt;
&lt;p&gt;The view we &lt;em&gt;do&lt;/em&gt; want to look at is our &lt;tt class="docutils literal"&gt;POIUpdateView&lt;/tt&gt; which is the one that let's users submit
changes for a particular POI. Now, this view is the one that's linked to for each record on the
list page; we never link to a view where a user can directly update a POI, not even for
editors/superusers. So, here's our &lt;tt class="docutils literal"&gt;POIUpdateView&lt;/tt&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;span class="label label-info"&gt;note&lt;/span&gt; We use a few mixins below that aren't part of the standard Django library: &lt;tt class="docutils literal"&gt;LoginRequiredMixin&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;PermissionRequiredMixin&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;SuccessURLRedirectListMixin&lt;/tt&gt;, and &lt;tt class="docutils literal"&gt;SetHeadlineMixin&lt;/tt&gt;.&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class POIUpdateView(LoginRequiredMixin, PermissionRequiredMixin,&lt;/span&gt;
&lt;span class="x"&gt;    SuccessURLRedirectListMixin, SetHeadlineMixin, CreateView):&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    View allows users to propose changes to current POIs.&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="x"&gt;    form_class = POIChangeForm&lt;/span&gt;
&lt;span class="x"&gt;    headline = &amp;quot;Edit point of interest&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    model = POIChange&lt;/span&gt;
&lt;span class="x"&gt;    permission_required = &amp;quot;points.change_poi&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    success_list_url = &amp;quot;cms_points_list&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    template_name = &amp;quot;cms/points/poi_form_edit.html&amp;quot;&lt;/span&gt;

&lt;span class="x"&gt;    def get_initial(self):&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        Do you believe in magic, in a young devs heart?&lt;/span&gt;
&lt;span class="x"&gt;        How the code can free &amp;#39;em whenever it starts,&lt;/span&gt;
&lt;span class="x"&gt;        and it&amp;#39;s magic, if the code is groovy.&lt;/span&gt;

&lt;span class="x"&gt;        Use POI information for initial data in POIChangeForm.&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        poi = POI.objects.get(pk=self.kwargs[&amp;quot;pk&amp;quot;])&lt;/span&gt;
&lt;span class="x"&gt;        initial = poi.__dict__.copy()&lt;/span&gt;
&lt;span class="x"&gt;        del initial[&amp;quot;_state&amp;quot;]&lt;/span&gt;
&lt;span class="x"&gt;        initial.update({&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;category&amp;quot;: poi.category,&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;latitude&amp;quot;: poi.point.get_coords()[1],&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;longitude&amp;quot;: poi.point.get_coords()[0],&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;user&amp;quot;: self.request.user,&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;poi&amp;quot;: poi&lt;/span&gt;
&lt;span class="x"&gt;        })&lt;/span&gt;
&lt;span class="x"&gt;        return initial&lt;/span&gt;

&lt;span class="x"&gt;    def post(self, request, pk, *args, **kwargs):&lt;/span&gt;
&lt;span class="x"&gt;        response = super(POIUpdateView, self).post(request, pk, *args, **kwargs)&lt;/span&gt;

&lt;span class="x"&gt;        url = settings.CMS_URL + reverse(&amp;quot;cms_points_change_detail&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;            kwargs={&amp;quot;pk&amp;quot;: self.object.pk})&lt;/span&gt;
&lt;span class="x"&gt;        message = render_to_string(&amp;quot;cms/points/email/admin_email.html&amp;quot;, {&amp;quot;user&amp;quot;:&lt;/span&gt;
&lt;span class="x"&gt;            self.object.user.get_full_name(), &amp;quot;url&amp;quot;: url})&lt;/span&gt;
&lt;span class="x"&gt;        mail_admins(&amp;quot;POI Change Request&amp;quot;, message)&lt;/span&gt;

&lt;span class="x"&gt;        return response&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I think how this view works is pretty cool. It's a fairly standard &lt;tt class="docutils literal"&gt;CreateView&lt;/tt&gt; that points to
our &lt;tt class="docutils literal"&gt;POIChange&lt;/tt&gt; model. We don't just start with a blank &lt;tt class="docutils literal"&gt;POIChange&lt;/tt&gt;, though. By overriding
&lt;tt class="docutils literal"&gt;get_initial&lt;/tt&gt; to load the &lt;tt class="docutils literal"&gt;POI&lt;/tt&gt; with the &lt;tt class="docutils literal"&gt;PK&lt;/tt&gt; that comes through in the URL, we can set the
beginning data of the record. We fetch the instance, update our initial data with its values, and
then pass it on through to the form.&lt;/p&gt;
&lt;p&gt;Once the form is valid, a method I don't show above, called &lt;tt class="docutils literal"&gt;form_valid&lt;/tt&gt;, is fired by Django as part of its form-based generic view workflow and then we log the change in our logger, send a message to the user
through Django's &lt;tt class="docutils literal"&gt;messages&lt;/tt&gt; app, and then our &lt;tt class="docutils literal"&gt;post&lt;/tt&gt; method gets called.  Learning the workflow order of &lt;tt class="docutils literal"&gt;CreateView&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;UpdateView&lt;/tt&gt; (and, ultimately, &lt;tt class="docutils literal"&gt;FormView&lt;/tt&gt;) will save you a huge amount of time when
you start customizing these things.  In our &lt;tt class="docutils literal"&gt;post&lt;/tt&gt; method, we render out an email to the admins and then return our response, which, thanks to our &lt;tt class="docutils literal"&gt;SuccessURLRedirectListMixin&lt;/tt&gt; will redirect the user to the route
named in &lt;tt class="docutils literal"&gt;success_list_url&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Now, all we've really done is create a new record. It still has to be approved. We do that in our
next view, &lt;tt class="docutils literal"&gt;POIChangeApprovalView&lt;/tt&gt;, which the editor/superuser gets to through another list
view. They can also reach it by clicking the link provided to them in the email.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class POIChangeApprovalView(LoginRequiredMixin, SuperuserRequiredMixin,&lt;/span&gt;
&lt;span class="x"&gt;    DetailView):&lt;/span&gt;

&lt;span class="x"&gt;    model = POIChange&lt;/span&gt;
&lt;span class="x"&gt;    template_name = &amp;quot;cms/points/poi_change_detail.html&amp;quot;&lt;/span&gt;

&lt;span class="x"&gt;    def post(self, request, pk):&lt;/span&gt;
&lt;span class="x"&gt;        approval = request.POST.get(&amp;quot;approval&amp;quot;, None)&lt;/span&gt;
&lt;span class="x"&gt;        if approval:&lt;/span&gt;
&lt;span class="x"&gt;            if approval == &amp;quot;approve&amp;quot;:&lt;/span&gt;
&lt;span class="x"&gt;                self._approved()&lt;/span&gt;
&lt;span class="x"&gt;            else:&lt;/span&gt;
&lt;span class="x"&gt;                self._denied()&lt;/span&gt;
&lt;span class="x"&gt;            return HttpResponseRedirect(reverse(&amp;quot;cms_points_change_list&amp;quot;))&lt;/span&gt;

&lt;span class="x"&gt;        return HttpResponseForbidden()&lt;/span&gt;

&lt;span class="x"&gt;    def _approved(self):&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        It&amp;#39;s approved!&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        poi = self.get_object()&lt;/span&gt;
&lt;span class="x"&gt;        data = poi.__dict__.copy()&lt;/span&gt;
&lt;span class="x"&gt;        del data[&amp;quot;_state&amp;quot;]&lt;/span&gt;
&lt;span class="x"&gt;        data.update({&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;category&amp;quot;: poi.category.pk,&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;latitude&amp;quot;: poi.coords[0],&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;longitude&amp;quot;: poi.coords[1],&lt;/span&gt;
&lt;span class="x"&gt;        })&lt;/span&gt;
&lt;span class="x"&gt;        form = POIForm(data, instance=poi.poi)&lt;/span&gt;
&lt;span class="x"&gt;        if form.is_valid():&lt;/span&gt;
&lt;span class="x"&gt;            form.save()&lt;/span&gt;

&lt;span class="x"&gt;            poi.status = 2&lt;/span&gt;
&lt;span class="x"&gt;            poi.approved_by = self.request.user&lt;/span&gt;
&lt;span class="x"&gt;            poi.approved_on = date.today()&lt;/span&gt;
&lt;span class="x"&gt;            poi.save()&lt;/span&gt;

&lt;span class="x"&gt;            messages.success(self.request, &amp;quot;Point of interest updated.&amp;quot;)&lt;/span&gt;

&lt;span class="x"&gt;            if poi.user.email:&lt;/span&gt;
&lt;span class="x"&gt;                message = render_to_string(&amp;quot;cms/points/email/approved.html&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;                    {&amp;quot;poi_name&amp;quot;: poi.name})&lt;/span&gt;
&lt;span class="x"&gt;                send_mail(&amp;quot;OUR CLIENT - Change Request Approved&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;                    message, settings.EMAIL_HOST_USER, [poi.user.email])&lt;/span&gt;

&lt;span class="x"&gt;    def _denied(self):&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        No way Jose&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        poi = self.get_object()&lt;/span&gt;
&lt;span class="x"&gt;        poi.status = 1&lt;/span&gt;
&lt;span class="x"&gt;        poi.approved_by = self.request.user&lt;/span&gt;
&lt;span class="x"&gt;        poi.approved_on = date.today()&lt;/span&gt;
&lt;span class="x"&gt;        poi.save()&lt;/span&gt;

&lt;span class="x"&gt;        messages.success(self.request,&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;Point of interest &amp;#39;%s&amp;#39; has not been updated.&amp;quot; % poi.poi.name)&lt;/span&gt;

&lt;span class="x"&gt;        if poi.user.email:&lt;/span&gt;
&lt;span class="x"&gt;            message = render_to_string(&amp;quot;cms/points/email/denied.html&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;                {&amp;quot;poi_name&amp;quot;: poi.name})&lt;/span&gt;
&lt;span class="x"&gt;            send_mail(&amp;quot;OUR CLIENT - Change Request Denied&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;                message, settings.EMAIL_HOST_USER, [poi.user.email])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This view is really straightfoward. The editor clicks one of two buttons, both of which point to
this view. One contains a &lt;tt class="docutils literal"&gt;POST&lt;/tt&gt; variable indicating approval, the other indicating that the
change has been denied. Then, based on the value, we peform the same action on the &lt;tt class="docutils literal"&gt;POIChange&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;If the change was denied, we just set the status on the change to our denied flag, set the date
and user, and then save it.&lt;/p&gt;
&lt;p&gt;If it was approved, we create an instance of the &lt;tt class="docutils literal"&gt;POIForm&lt;/tt&gt; with the changed &lt;tt class="docutils literal"&gt;POI&lt;/tt&gt; as the
edited instance and our &lt;tt class="docutils literal"&gt;POIChange&lt;/tt&gt;'s &lt;tt class="docutils literal"&gt;__dict__&lt;/tt&gt; as the new data. Since they're copies of each
other, aside from the changes in the change model, of course, only the changed data really gets
updated. We make sure the form is still valid (some &lt;a class="reference external" href="http://geodjango.org"&gt;GeoDjango&lt;/a&gt; stuff I left out of the form above)
and then save the updated instance. We also update the &lt;tt class="docutils literal"&gt;POIChange&lt;/tt&gt; so it holds the new status,
the approving user and date.&lt;/p&gt;
&lt;p&gt;Regardless of the action taken, we send off an email to the user that submitted the change,
letting him or her know what happened.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;This has, so far, been a great workflow for our users. They're able to trust that the data going
out is verified and safe, but if anything gets out of date, we can change it ourselves or let the community of users tell us about the new data.&lt;/p&gt;
&lt;p&gt;There is a lot of stuff I didn't cover, what the &lt;tt class="docutils literal"&gt;Point&lt;/tt&gt; field holds on to, how to actually use GeoDjango, what each of our custom mixins does (we're planning on releasing these as a package soon), and lots of other
stuff. If you have questions/comments, hit us up on &lt;a class="reference external" href="http://twitter.com/brack3t"&gt;Twitter&lt;/a&gt;. Also, thanks to &lt;a class="reference external" href="http://pydanny.github.com"&gt;Daniel Greenfeld&lt;/a&gt; for a couple of edits.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="django"></category><category term="workflow"></category><category term="python"></category></entry><entry><title>Semantic Snakeoil</title><link href="http://brack3t.com/semantic-snakeoil.html" rel="alternate"></link><updated>2011-10-03T21:31:00Z</updated><author><name>Kenneth</name></author><id>tag:brack3t.com,2011-10-03:/semantic-snakeoil.html/</id><summary type="html">&lt;p&gt;For years now, we've been told that we should always use semantic class names and IDs in our HTML.
And, in general, this is a good practice, I don't want anyone to think it's not. You &lt;em&gt;should&lt;/em&gt; make
your markup, all aspects of it, as accurate and related as possible. The problem, though, comes
when people become fanatical about their classes and IDs to the point of swearing off grid systems
and CSS frameworks in the name of &amp;quot;proper&amp;quot; web development practices.&lt;/p&gt;
&lt;p&gt;So why isn't it a big deal? Both the &lt;a class="reference external" href="http://www.w3.org/TR/html5-author/global-attributes.html#classes"&gt;W3C&lt;/a&gt; and the &lt;a class="reference external" href="http://developers.whatwg.org/elements.html#classes"&gt;WHATWG&lt;/a&gt; emphasize that the class attribute, and its values, if specified, should describe the nature of the content and not the presentation of it. And for the most part, I agree. This ideal has limits, though, that need to be addressed and understood. &lt;strong&gt;It's currently impossible to be 100% semantic and still be useful.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Let's start with the argument presented by the idealists: All class names and IDs should be semantic and address the nature of the element, not its display. This ends up with us needing to create new classes and ID for every project we do, tied directly to the use case of each bit of markup. Yes, some things could be repeated and copied from project to project, but a decent majority of the CSS would be unique. This is great if you're the only person working on something, or working with a small group that works together on many projects. This is rarely the case with large or open-source projects, though.&lt;/p&gt;
&lt;p&gt;Now, let's look at the argument from the utilitarians: All class names should be generically semantic to the structure of the document and relate to the use case and nature of the element; IDs should be semantic to the project or page. This opens up the project to third-party grid systems and the like. So long as the class names have meaning to the document, even if it's not semantic meaning to the content it's wrapped around, it's still valid and logical.&lt;/p&gt;
&lt;p&gt;For a second argument against made-to-order frameworks for each project: using third-party libraries like the awesome &lt;a class="reference external" href="https://twitter.github.com/bootstrap/"&gt;Twitter Bootstrap&lt;/a&gt;, newcomers to the project will either have experience with the library, or can refer to its documentation to get up to speed; if you're using a custom library of CSS for the project, a new developer needs to familiarize themselves with the whole thing with, lilkely, little to no documentation.&lt;/p&gt;
&lt;p&gt;To my mind, and many other professionals, the point of the &lt;tt class="docutils literal"&gt;class&lt;/tt&gt; attribute is to describe the element or its content. The element, though, is the more important bit to describe since using a semantic element already describes the content. If you put a list of links into a &lt;tt class="docutils literal"&gt;&amp;lt;nav&amp;gt;&lt;/tt&gt; element, there's no reason to give it a class of &lt;tt class="docutils literal"&gt;nav&lt;/tt&gt; or &lt;tt class="docutils literal"&gt;menu&lt;/tt&gt; or the like. There is, however, plenty of reason to give it a class that describes how it relates to other elements, such as &lt;tt class="docutils literal"&gt;span6&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Using these systems, as well, gives us the ability to reflow content in a way that remains semantic. To set the stage, we have a &lt;tt class="docutils literal"&gt;&amp;lt;section&amp;gt;&lt;/tt&gt; of content that is the main content of the site, and an &lt;tt class="docutils literal"&gt;&amp;lt;aside&amp;gt;&lt;/tt&gt; that is our sidebar. We want the page to reflow based on media queries.  If we use an idealistic set of classes, such as &lt;tt class="docutils literal"&gt;sidebar&lt;/tt&gt;, once the page reflows and the &lt;tt class="docutils literal"&gt;&amp;lt;aside&amp;gt;&lt;/tt&gt; ends up below the main content, its class no longer has the same semantic meaning. Yes, we could have used a class like &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;secondary-content&lt;/span&gt;&lt;/tt&gt; or the like, but few people seem to use class names like this. If, though, we use something like &lt;tt class="docutils literal"&gt;span6&lt;/tt&gt;, it loses no semantic meaning after the reflow as it is still spanning 6 of our columns. Yes, that's describing the display but it's describing it on relation to all the other elements, so it is semantic in context.&lt;/p&gt;
&lt;p&gt;The other point I keep seeing being made is, that, to change the width of an element, the designer has to go and edit the HTML. If, though, you're using HTML correctly, to where classes describe more than one object, if I want only one instance of an object to be wider, I have to either add, remove, or edit a class in the HTML anyway. If your knee-jerk reaction is that &amp;quot;my classes aren't set up that way&amp;quot; and you're using classes like they're IDs, to where they're unique, you aren't using them correctly and should be using IDs on your elements. This also ties into more serious programming; if your model changes, you have to (usually) update your views/controllers and templates/views. This isn't a unique concept and shouldn't trip up any serious developer or designer.&lt;/p&gt;
&lt;p&gt;Search engines don't seem to care about class values, either, so using more of them won't hurt your site's SEO (if you care about that). Also, as far as content being available, if people are scraping your HTML, it would be better to offer it in a more consumable format like an JSON API or an RSS feed (aka XML). This way the content is separated from your presentation of it and can be used however the consumer needs it.&lt;/p&gt;
&lt;p&gt;So, I put forth a new definition for classes:&lt;/p&gt;
&lt;blockquote&gt;
There are no additional restrictions on the tokens authors can use in the class attribute, but authors are encouraged to use values that describe the nature of the content, rather than values that describe the desired presentation of the content. &lt;strong&gt;It is also valid to use values that describe the element.&lt;/strong&gt;&lt;/blockquote&gt;
&lt;p&gt;Have comments? Continue the discussion on &lt;a class="reference external" href="http://news.ycombinator.com/item?id=3072260"&gt;Hacker News&lt;/a&gt;.&lt;/p&gt;
</summary><category term="semantics"></category><category term="html"></category><category term="css"></category></entry><entry><title>Djangopeople.me</title><link href="http://brack3t.com/djangopeopleme.html" rel="alternate"></link><updated>2011-06-13T18:50:00Z</updated><author><name>Chris</name></author><id>tag:brack3t.com,2011-06-13:/djangopeopleme.html/</id><summary type="html">&lt;div class="section" id="what-is-it"&gt;
&lt;h2&gt;What is it?&lt;/h2&gt;
&lt;p&gt;At it's core, &lt;a class="reference external" href="http://djangopeople.me"&gt;djangopeople.me&lt;/a&gt; is a place for &lt;a class="reference external" href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt; developers to register and be found based on their geographic location, whether it's by recruiters or a lonely Django developer like ourselves trying to find others close to him/her. That's the general idea behind the site.&lt;/p&gt;
&lt;p&gt;We wanted to make it clean, simple and fast. For the maps we ended up using &lt;a class="reference external" href="http://leaflet.cloudmade.com/"&gt;Leaflet's&lt;/a&gt; open-source Javascript library. We initially started with Google Maps, but the rate limiting was too restrictive on the geocoding API for our needs and frankly, loading maps seemed very slow. So, with the project being free-to-use (and us being cheap), we looked for something else.&lt;/p&gt;
&lt;p&gt;Yahoo! Maps was the next step as they had a decent API and allowed more requests. Google currently allows 2,500 requests per day and Yahoo allows 5,000 requests (geocoding). Yahoo's maps were faster to load but we seemed to have nothing but issues with &lt;a class="reference external" href="http://google.com/chrome"&gt;Google Chome&lt;/a&gt; throwing a YMAP Javascript error we could never track down. We didn't think it would be all that awesome telling Chrome users to clear their cache up to three times before the maps would load again (If you've had this issue and a have fix, for the love of all that is holy, let us know about it please).&lt;/p&gt;
&lt;p&gt;After searching around for a day, we came across &lt;a class="reference external" href="http://leaflet.cloudmade.com/"&gt;Leaflet&lt;/a&gt;. It was simple to implement and the maps were extremely fast to load compared to Google and Yahoo. You could also make the argument that they don't have nearly the traffic that Google and Yahoo have but Leaftlet was simple and it worked. Also, our scientific method for testing the load times was simply us reloading pages over and over as we worked on functionality. So don't expect any charts. Chris is an impatient guy, so if he gets annoyed by something he's built, it's not going live.&lt;/p&gt;
&lt;p&gt;There is one issue we ran into with Leaflet and it has yet to be resolved. Their geocoding API, after about two weeks of use, started retuning funky results. By funky I mean, resolving &lt;em&gt;Las Vegas, NV&lt;/em&gt;, to Livingston, Illinois. &lt;em&gt;Dallas, TX&lt;/em&gt; would come back as being in Australia. Chris emailed their support team and they have confirmed it is a bug but they do not have an idea of when it will be resolved. Aside from that, their service has been fantastic.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="it-s-already-been-done"&gt;
&lt;h2&gt;It's already been done.&lt;/h2&gt;
&lt;p&gt;This is true, &lt;a class="reference external" href="http://djangopeople.net"&gt;djangopeople.net&lt;/a&gt; was the inspiration for building djangopeople.me. We realized that djangopeople.net had been down for some time, intermittently. It was useful and we had both been contacted by people looking for Django developers through that site. So the original idea was to bring that functionality back and hopefully make it better.&lt;/p&gt;
&lt;p&gt;Kenneth came across a posting on &lt;a class="reference external" href="http://convore.com"&gt;Convore&lt;/a&gt; when we were almost ready to launch the site. It appeared that a group of developers were getting together to bring djangopeople.net back online. We almost stopped working on the site as dp.net came back online for a short time. It was really slow and then ended up going back down a day later. So we decided to finish the small bug fixes we were working on and launch it.&lt;/p&gt;
&lt;p&gt;So, just to be clear, djangopeople.me was inspired by &lt;a class="reference external" href="http://djangopeople.net"&gt;djangopeople.net&lt;/a&gt;. We just wanted to bring that back to the Python/Django community. We believe the interface is better and faster. Also, using &lt;a class="reference external" href="http://twitter.com"&gt;Twitter&lt;/a&gt; as the main auth system made it dead simple to sign up. We've had a few people ask for other authentication methods but at the moment Twitter provided exactly what we wanted with no hassle.&lt;/p&gt;
&lt;p&gt;We use your Twitter username so it's very easy to find a profile of someone you already know and follow. This also makes it a little difficult to add other authentication methods as we'll now have to deal with allowing people to choose usernames and possibly picking a Twitter username that a future developer would sign up with. We're open to suggestions but we like the simplicity of using Twitter. Having recently wrapped up a project using the &lt;a class="reference external" href="https://github.com/facebook/python-sdk"&gt;Facebook Python SDK&lt;/a&gt;, it was nice for Twitter's auth system to just work and not get in the way.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-s-next"&gt;
&lt;h2&gt;What's next?&lt;/h2&gt;
&lt;p&gt;We've had a good amount of people sign up and we've gotten some good feedback. We have a couple of
ideas for tying into other Django services but we're waiting for replies to our emails at the
moment. We both contract/freelance full time, so we'll probably spend the next week or two throwing
ideas around before we know what the next step is. In the meantime, check out the site and let us
know what you love and/or hate about it. We've got thick skins.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="python"></category><category term="django"></category><category term="project"></category></entry></feed>