<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>brack3t</title><link href="http://brack3t.com" rel="alternate"></link><link href="http://brack3t.com/feeds/django.atom.xml" rel="self"></link><id>http://brack3t.com</id><updated>2012-02-29T21:05:18Z</updated><entry><title>Generic Layouts in Crispy Forms</title><link href="http://brack3t.com/generic-layouts-in-crispy-forms.html" rel="alternate"></link><updated>2012-02-29T21:05:18Z</updated><author><name>Kenneth</name></author><id>tag:brack3t.com,2012-02-29:/generic-layouts-in-crispy-forms.html/</id><summary type="html">&lt;p&gt;Just a quick tip and sanity check, today, about something I ran into with &lt;a class="reference external" href="https://github.com/maraujop/django-crispy-forms"&gt;django-crispy-forms&lt;/a&gt;, the awesome new form library from Miguel Araujo.&lt;/p&gt;
&lt;p&gt;This morning, I converted the project we've been building for a client (currently some 1,700 or so files, counting templates, CSS, and icons) from &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;django-uni-form&lt;/span&gt;&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;django-crispy-forms&lt;/span&gt;&lt;/tt&gt;. It's a pretty painless
transition, actually. Just do some find-and-replace across your files, basically changing any instance of &lt;tt class="docutils literal"&gt;uni-&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;crispy-&lt;/tt&gt; (well, and &lt;tt class="docutils literal"&gt;form&lt;/tt&gt; to &lt;tt class="docutils literal"&gt;forms&lt;/tt&gt;), and you're good to go. Then, however, I wanted to
convert two large forms that we have, which share 90% of their fields, to using the sharable &lt;tt class="docutils literal"&gt;Layout&lt;/tt&gt; objects that &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;django-crispy-forms&lt;/span&gt;&lt;/tt&gt; gives us.&lt;/p&gt;
&lt;p&gt;Basically, the forms looked like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class FirstForm(GenericAppFormForTheExample):&lt;/span&gt;
&lt;span class="x"&gt;    ...&lt;/span&gt;

&lt;span class="x"&gt;    def __init__(self, *args, **kwargs):&lt;/span&gt;
&lt;span class="x"&gt;        ...&lt;/span&gt;
&lt;span class="x"&gt;        self.helper = FormHelper()&lt;/span&gt;
&lt;span class="x"&gt;        self.helper.layout = Layout(&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;field1&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;field2&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;special-field&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;            [field3 through field20]&lt;/span&gt;

&lt;span class="x"&gt;class SecondForm(GenericAppFormForTheExample):&lt;/span&gt;
&lt;span class="x"&gt;    ...&lt;/span&gt;

&lt;span class="x"&gt;    def __init__(self, *args, **kwargs):&lt;/span&gt;
&lt;span class="x"&gt;        ...&lt;/span&gt;
&lt;span class="x"&gt;        self.helper = FormHelper()&lt;/span&gt;
&lt;span class="x"&gt;        self.helper.layout = Layout(&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;field1&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;field2&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;special-field2&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;            [field3 thorugh field20]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Obviously that was a lot of repetition that we could cut out now that these inheritable layouts exist. By the way, I'm pretty sure this would have been possible in &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;django-uni-form&lt;/span&gt;&lt;/tt&gt; but likely not as friendly.&lt;/p&gt;
&lt;p&gt;First I started off by creating the shared resources. I made two of them since our special fields come in the middle of our layouts.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;form_intro_layout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Layout&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;field1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
    &lt;span class="s"&gt;&amp;quot;field2&amp;quot;&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;form_common_layout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Layout&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;field3&lt;/span&gt; &lt;span class="n"&gt;through&lt;/span&gt; &lt;span class="n"&gt;field20&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And I added them each into my forms. I'm only going to show one form but you'll get the idea.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;self.form_intro_layout = form_intro_layout&lt;/span&gt;
&lt;span class="x"&gt;self.form_intro_layout.insert(-1, &amp;quot;special-field&amp;quot;)&lt;/span&gt;

&lt;span class="x"&gt;self.helper.layout = Layout(&lt;/span&gt;
&lt;span class="x"&gt;    self.form_intro_layout,&lt;/span&gt;
&lt;span class="x"&gt;    form_common_layout&lt;/span&gt;
&lt;span class="x"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And, display-wise, it worked fine. This is, ideally, exactly what you do to extend these layouts. &lt;strong&gt;But&lt;/strong&gt;, this causes problems in testing.&lt;/p&gt;
&lt;p&gt;We test all of our views, models, and forms. The form tests passed fine, but some of the view tests were throwing up warnings about fields being referenced more than once and, for example, &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;special-field2&lt;/span&gt;&lt;/tt&gt; missing
from &lt;tt class="docutils literal"&gt;FirstForm&lt;/tt&gt;. Obviously something was up with the inheritance and with how I was instantiating objects.&lt;/p&gt;
&lt;p&gt;My next step was to stop using &lt;tt class="docutils literal"&gt;self&lt;/tt&gt; on the instance-specific versions of the generic layouts and just give them a local name like &lt;tt class="docutils literal"&gt;standard_intro_layout&lt;/tt&gt; (the &lt;tt class="docutils literal"&gt;standard&lt;/tt&gt; name makes more sense internally and its
meaning isn't important for this example), but that didn't stop the errors. It did, however, still work fine visually.&lt;/p&gt;
&lt;p&gt;I tried using a &lt;tt class="docutils literal"&gt;.copy()&lt;/tt&gt; method on the layout, but that doesn't exist. So I turned to the &lt;tt class="docutils literal"&gt;copy&lt;/tt&gt; module of Python, specifically the &lt;tt class="docutils literal"&gt;deepcopy&lt;/tt&gt; method. I tried with just the standard &lt;tt class="docutils literal"&gt;copy&lt;/tt&gt; method, but it had
the same effect of working visually, but throwing warnings on tests.&lt;/p&gt;
&lt;p&gt;The new version looked like this:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;from copy import deepcopy&lt;/span&gt;

&lt;span class="x"&gt;standard_intro_layout = deepcopy(form_intro_layout)&lt;/span&gt;
&lt;span class="x"&gt;standard_intro_layout.insert(-1, &amp;quot;special-field&amp;quot;)&lt;/span&gt;
&lt;span class="x"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That works perfectly! It still appears the same visually, like all the methods have, and it also quiets the tests so they pass without warnings.&lt;/p&gt;
&lt;p&gt;Unless someone knows of a reason I shouldn't use &lt;tt class="docutils literal"&gt;deepcopy&lt;/tt&gt;, this seems to be the way to solve this problem. I'm also not sure if it was the &lt;tt class="docutils literal"&gt;self&lt;/tt&gt; (which I doubt, since I removed it and the warnings still
happened), or the fact that both forms extend the same abstract form, or some other variable that led to the problem. Regardless, I'm happy to have solved it.&lt;/p&gt;
</summary><category term="django"></category><category term="django-crispy-forms"></category><category term="tip"></category></entry><entry><title>Change Request Workflow</title><link href="http://brack3t.com/change-request-workflow.html" rel="alternate"></link><updated>2012-02-26T11:01:00Z</updated><author><name>Kenneth</name></author><id>tag:brack3t.com,2012-02-26:/change-request-workflow.html/</id><summary type="html">&lt;p&gt;Before we start, let me explain a bit about what the app we're covering here is. It's a geo-spatial database, basically, of
Points of Interest (POIs) for housing communities that we developed for a client of ours (or, rather, are still developing).
Users and editors can both enter Points into the database, which is PostgreSQL with PostGIS, and then they can be associated
with any community.  Obviosuly, though, that leads to the problem of Community A editing a POI and Community B showing that data
without their knowledge, so we'd like to have an editor look at the changes first. That's the need that lead to our workflow.&lt;/p&gt;
&lt;div class="section" id="models"&gt;
&lt;h2&gt;Models&lt;/h2&gt;
&lt;p&gt;First, let's start with the models.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class POIAbstract(LumberjackModel, models.Model):&lt;/span&gt;
&lt;span class="x"&gt;    category = models.ForeignKey(Category, related_name=&amp;quot;%(class)s_points&amp;quot;)&lt;/span&gt;
&lt;span class="x"&gt;    name = models.CharField(max_length=255)&lt;/span&gt;
&lt;span class="x"&gt;    address = models.CharField(max_length=255)&lt;/span&gt;
&lt;span class="x"&gt;    address2 = models.CharField(max_length=255, blank=True)&lt;/span&gt;
&lt;span class="x"&gt;    city = models.CharField(max_length=100)&lt;/span&gt;
&lt;span class="x"&gt;    state = USPostalCodeField()&lt;/span&gt;
&lt;span class="x"&gt;    zip_code = models.CharField(max_length=10)&lt;/span&gt;
&lt;span class="x"&gt;    phone = PhoneNumberField(blank=True, default=&amp;quot;&amp;quot;)&lt;/span&gt;
&lt;span class="x"&gt;    url = models.URLField(blank=True, default=&amp;quot;&amp;quot;)&lt;/span&gt;
&lt;span class="x"&gt;    point = models.PointField(blank=True, null=True, editable=False)&lt;/span&gt;
&lt;span class="x"&gt;    objects = models.GeoManager()&lt;/span&gt;

&lt;span class="x"&gt;    class Meta:&lt;/span&gt;
&lt;span class="x"&gt;        abstract = True&lt;/span&gt;

&lt;span class="x"&gt;    def __unicode__(self):&lt;/span&gt;
&lt;span class="x"&gt;        return self.name&lt;/span&gt;

&lt;span class="x"&gt;    @property&lt;/span&gt;
&lt;span class="x"&gt;    def coords(self):&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        Return tuple of lat,lng&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        if self.point:&lt;/span&gt;
&lt;span class="x"&gt;            return (self.point.get_coords()[1], self.point.get_coords()[0])&lt;/span&gt;
&lt;span class="x"&gt;        return (None, None)&lt;/span&gt;

&lt;span class="x"&gt;    @property&lt;/span&gt;
&lt;span class="x"&gt;    def full_address(self):&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        Return a string of the full address&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        addresses = [self.address, self.address2, self.city, self.state,&lt;/span&gt;
&lt;span class="x"&gt;            self.zip_code, &amp;quot;USA&amp;quot;]&lt;/span&gt;
&lt;span class="x"&gt;        return &amp;quot;, &amp;quot;.join(filter(lambda x: len(x) &amp;gt; 0, addresses))&lt;/span&gt;


&lt;span class="x"&gt;class POI(POIAbstract):&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    Points of Interest model.&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    pass&lt;/span&gt;


&lt;span class="x"&gt;class POIChange(POIAbstract):&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    Holds proposed changes to POIs&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    STATUS_CHOICES = (&lt;/span&gt;
&lt;span class="x"&gt;        (0, &amp;quot;Pending&amp;quot;),&lt;/span&gt;
&lt;span class="x"&gt;        (1, &amp;quot;Denied&amp;quot;),&lt;/span&gt;
&lt;span class="x"&gt;        (2, &amp;quot;Approved&amp;quot;)&lt;/span&gt;
&lt;span class="x"&gt;    )&lt;/span&gt;

&lt;span class="x"&gt;    poi = models.ForeignKey(POI, related_name=&amp;quot;changes&amp;quot;)&lt;/span&gt;
&lt;span class="x"&gt;    user = models.ForeignKey(User, related_name=&amp;quot;poi_changes&amp;quot;)&lt;/span&gt;
&lt;span class="x"&gt;    submitted_on = models.DateField(auto_now_add=True, editable=False)&lt;/span&gt;
&lt;span class="x"&gt;    approved_by = models.ForeignKey(User, related_name=&amp;quot;poi_approvals&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;        blank=True, null=True, editable=False)&lt;/span&gt;
&lt;span class="x"&gt;    approved_on = models.DateField(blank=True, null=True, editable=False)&lt;/span&gt;
&lt;span class="x"&gt;    status = models.PositiveSmallIntegerField(choices=STATUS_CHOICES,&lt;/span&gt;
&lt;span class="x"&gt;        default=0, editable=False)&lt;/span&gt;

&lt;span class="x"&gt;    class Meta:&lt;/span&gt;
&lt;span class="x"&gt;        ordering = [&amp;quot;status&amp;quot;, &amp;quot;-submitted_on&amp;quot;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;As you can see, there's not really anything too interesting about the models. We have an abstract model that we inherit both of our other models from. The approved record model is just the abstract model without it's
&lt;tt class="docutils literal"&gt;abstract = True&lt;/tt&gt; setting. The change model, though, adds a few fields.&lt;/p&gt;
&lt;p&gt;First we point to the record we're changing. Then we hold on to the user that submitted the changes, and the time of the request. We also want to have a record of who approved/denied it and when. And, of course, we
need to know what the status of the change is. That'll let us change our minds later on.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="forms"&gt;
&lt;h2&gt;Forms&lt;/h2&gt;
&lt;p&gt;We usually end up building forms after we build models (more on this when we finish &lt;a class="reference external" href="http://gettingstartedwithdjango.com"&gt;GSWD&lt;/a&gt;), so let's look at them next.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class POIForm(forms.ModelForm):&lt;/span&gt;
&lt;span class="x"&gt;    latitude = forms.FloatField(required=False,&lt;/span&gt;
&lt;span class="x"&gt;        widget=forms.HiddenInput())&lt;/span&gt;
&lt;span class="x"&gt;    longitude = forms.FloatField(required=False,&lt;/span&gt;
&lt;span class="x"&gt;        widget=forms.HiddenInput())&lt;/span&gt;

&lt;span class="x"&gt;    class Meta:&lt;/span&gt;
&lt;span class="x"&gt;        model = POI&lt;/span&gt;


&lt;span class="x"&gt;class POIChangeForm(forms.ModelForm):&lt;/span&gt;
&lt;span class="x"&gt;    latitude = forms.FloatField(required=False,&lt;/span&gt;
&lt;span class="x"&gt;        widget=forms.HiddenInput())&lt;/span&gt;
&lt;span class="x"&gt;    longitude = forms.FloatField(required=False,&lt;/span&gt;
&lt;span class="x"&gt;        widget=forms.HiddenInput())&lt;/span&gt;

&lt;span class="x"&gt;    class Meta:&lt;/span&gt;
&lt;span class="x"&gt;        model = POIChange&lt;/span&gt;
&lt;span class="x"&gt;        widgets = {&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;poi&amp;quot;: forms.HiddenInput(),&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;user&amp;quot;: forms.HiddenInput()&lt;/span&gt;
&lt;span class="x"&gt;        }&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I've left out some of the boilerplate and &lt;tt class="docutils literal"&gt;Layout&lt;/tt&gt; bits from &lt;a class="reference external" href="https://github.com/pydanny/django-uni-form"&gt;django-uni-form&lt;/a&gt; (we haven't upgraded to &lt;a class="reference external" href="https://github.com/maraujop/django-crispy-forms"&gt;django-crispy-forms&lt;/a&gt; yet) but you get the general idea. Honestly, we could have made the second form inherit from
the first and saved a bit of typing/space, but I guess we missed that. Both forms, ultimately, show the same thing. The latter form, though, holds onto a few extra fields that we need and that we'll set in the view.&lt;/p&gt;
&lt;p&gt;Speaking of views, let's check them out.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="views"&gt;
&lt;h2&gt;Views&lt;/h2&gt;
&lt;p&gt;We're not going to look at the view that creates the original POI. It's just a standard
&lt;tt class="docutils literal"&gt;CreateView&lt;/tt&gt; that specifies our &lt;tt class="docutils literal"&gt;POIForm&lt;/tt&gt; as the &lt;tt class="docutils literal"&gt;form_class&lt;/tt&gt;. We have a couple of handy
mixins on the views that let us control permissions and redirects, but we'll talk about them in
another blog post.&lt;/p&gt;
&lt;p&gt;The view we &lt;em&gt;do&lt;/em&gt; want to look at is our &lt;tt class="docutils literal"&gt;POIUpdateView&lt;/tt&gt; which is the one that let's users submit
changes for a particular POI. Now, this view is the one that's linked to for each record on the
list page; we never link to a view where a user can directly update a POI, not even for
editors/superusers. So, here's our &lt;tt class="docutils literal"&gt;POIUpdateView&lt;/tt&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;span class="label label-info"&gt;note&lt;/span&gt; We use a few mixins below that aren't part of the standard Django library: &lt;tt class="docutils literal"&gt;LoginRequiredMixin&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;PermissionRequiredMixin&lt;/tt&gt;, &lt;tt class="docutils literal"&gt;SuccessURLRedirectListMixin&lt;/tt&gt;, and &lt;tt class="docutils literal"&gt;SetHeadlineMixin&lt;/tt&gt;.&lt;/blockquote&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class POIUpdateView(LoginRequiredMixin, PermissionRequiredMixin,&lt;/span&gt;
&lt;span class="x"&gt;    SuccessURLRedirectListMixin, SetHeadlineMixin, CreateView):&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    View allows users to propose changes to current POIs.&lt;/span&gt;
&lt;span class="x"&gt;    &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

&lt;span class="x"&gt;    form_class = POIChangeForm&lt;/span&gt;
&lt;span class="x"&gt;    headline = &amp;quot;Edit point of interest&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    model = POIChange&lt;/span&gt;
&lt;span class="x"&gt;    permission_required = &amp;quot;points.change_poi&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    success_list_url = &amp;quot;cms_points_list&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;    template_name = &amp;quot;cms/points/poi_form_edit.html&amp;quot;&lt;/span&gt;

&lt;span class="x"&gt;    def get_initial(self):&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        Do you believe in magic, in a young devs heart?&lt;/span&gt;
&lt;span class="x"&gt;        How the code can free &amp;#39;em whenever it starts,&lt;/span&gt;
&lt;span class="x"&gt;        and it&amp;#39;s magic, if the code is groovy.&lt;/span&gt;

&lt;span class="x"&gt;        Use POI information for initial data in POIChangeForm.&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        poi = POI.objects.get(pk=self.kwargs[&amp;quot;pk&amp;quot;])&lt;/span&gt;
&lt;span class="x"&gt;        initial = poi.__dict__.copy()&lt;/span&gt;
&lt;span class="x"&gt;        del initial[&amp;quot;_state&amp;quot;]&lt;/span&gt;
&lt;span class="x"&gt;        initial.update({&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;category&amp;quot;: poi.category,&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;latitude&amp;quot;: poi.point.get_coords()[1],&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;longitude&amp;quot;: poi.point.get_coords()[0],&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;user&amp;quot;: self.request.user,&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;poi&amp;quot;: poi&lt;/span&gt;
&lt;span class="x"&gt;        })&lt;/span&gt;
&lt;span class="x"&gt;        return initial&lt;/span&gt;

&lt;span class="x"&gt;    def post(self, request, pk, *args, **kwargs):&lt;/span&gt;
&lt;span class="x"&gt;        response = super(POIUpdateView, self).post(request, pk, *args, **kwargs)&lt;/span&gt;

&lt;span class="x"&gt;        url = settings.CMS_URL + reverse(&amp;quot;cms_points_change_detail&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;            kwargs={&amp;quot;pk&amp;quot;: self.object.pk})&lt;/span&gt;
&lt;span class="x"&gt;        message = render_to_string(&amp;quot;cms/points/email/admin_email.html&amp;quot;, {&amp;quot;user&amp;quot;:&lt;/span&gt;
&lt;span class="x"&gt;            self.object.user.get_full_name(), &amp;quot;url&amp;quot;: url})&lt;/span&gt;
&lt;span class="x"&gt;        mail_admins(&amp;quot;POI Change Request&amp;quot;, message)&lt;/span&gt;

&lt;span class="x"&gt;        return response&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;I think how this view works is pretty cool. It's a fairly standard &lt;tt class="docutils literal"&gt;CreateView&lt;/tt&gt; that points to
our &lt;tt class="docutils literal"&gt;POIChange&lt;/tt&gt; model. We don't just start with a blank &lt;tt class="docutils literal"&gt;POIChange&lt;/tt&gt;, though. By overriding
&lt;tt class="docutils literal"&gt;get_initial&lt;/tt&gt; to load the &lt;tt class="docutils literal"&gt;POI&lt;/tt&gt; with the &lt;tt class="docutils literal"&gt;PK&lt;/tt&gt; that comes through in the URL, we can set the
beginning data of the record. We fetch the instance, update our initial data with its values, and
then pass it on through to the form.&lt;/p&gt;
&lt;p&gt;Once the form is valid, a method I don't show above, called &lt;tt class="docutils literal"&gt;form_valid&lt;/tt&gt;, is fired by Django as part of its form-based generic view workflow and then we log the change in our logger, send a message to the user
through Django's &lt;tt class="docutils literal"&gt;messages&lt;/tt&gt; app, and then our &lt;tt class="docutils literal"&gt;post&lt;/tt&gt; method gets called.  Learning the workflow order of &lt;tt class="docutils literal"&gt;CreateView&lt;/tt&gt; and &lt;tt class="docutils literal"&gt;UpdateView&lt;/tt&gt; (and, ultimately, &lt;tt class="docutils literal"&gt;FormView&lt;/tt&gt;) will save you a huge amount of time when
you start customizing these things.  In our &lt;tt class="docutils literal"&gt;post&lt;/tt&gt; method, we render out an email to the admins and then return our response, which, thanks to our &lt;tt class="docutils literal"&gt;SuccessURLRedirectListMixin&lt;/tt&gt; will redirect the user to the route
named in &lt;tt class="docutils literal"&gt;success_list_url&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;Now, all we've really done is create a new record. It still has to be approved. We do that in our
next view, &lt;tt class="docutils literal"&gt;POIChangeApprovalView&lt;/tt&gt;, which the editor/superuser gets to through another list
view. They can also reach it by clicking the link provided to them in the email.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;class POIChangeApprovalView(LoginRequiredMixin, SuperuserRequiredMixin,&lt;/span&gt;
&lt;span class="x"&gt;    DetailView):&lt;/span&gt;

&lt;span class="x"&gt;    model = POIChange&lt;/span&gt;
&lt;span class="x"&gt;    template_name = &amp;quot;cms/points/poi_change_detail.html&amp;quot;&lt;/span&gt;

&lt;span class="x"&gt;    def post(self, request, pk):&lt;/span&gt;
&lt;span class="x"&gt;        approval = request.POST.get(&amp;quot;approval&amp;quot;, None)&lt;/span&gt;
&lt;span class="x"&gt;        if approval:&lt;/span&gt;
&lt;span class="x"&gt;            if approval == &amp;quot;approve&amp;quot;:&lt;/span&gt;
&lt;span class="x"&gt;                self._approved()&lt;/span&gt;
&lt;span class="x"&gt;            else:&lt;/span&gt;
&lt;span class="x"&gt;                self._denied()&lt;/span&gt;
&lt;span class="x"&gt;            return HttpResponseRedirect(reverse(&amp;quot;cms_points_change_list&amp;quot;))&lt;/span&gt;

&lt;span class="x"&gt;        return HttpResponseForbidden()&lt;/span&gt;

&lt;span class="x"&gt;    def _approved(self):&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        It&amp;#39;s approved!&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        poi = self.get_object()&lt;/span&gt;
&lt;span class="x"&gt;        data = poi.__dict__.copy()&lt;/span&gt;
&lt;span class="x"&gt;        del data[&amp;quot;_state&amp;quot;]&lt;/span&gt;
&lt;span class="x"&gt;        data.update({&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;category&amp;quot;: poi.category.pk,&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;latitude&amp;quot;: poi.coords[0],&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;longitude&amp;quot;: poi.coords[1],&lt;/span&gt;
&lt;span class="x"&gt;        })&lt;/span&gt;
&lt;span class="x"&gt;        form = POIForm(data, instance=poi.poi)&lt;/span&gt;
&lt;span class="x"&gt;        if form.is_valid():&lt;/span&gt;
&lt;span class="x"&gt;            form.save()&lt;/span&gt;

&lt;span class="x"&gt;            poi.status = 2&lt;/span&gt;
&lt;span class="x"&gt;            poi.approved_by = self.request.user&lt;/span&gt;
&lt;span class="x"&gt;            poi.approved_on = date.today()&lt;/span&gt;
&lt;span class="x"&gt;            poi.save()&lt;/span&gt;

&lt;span class="x"&gt;            messages.success(self.request, &amp;quot;Point of interest updated.&amp;quot;)&lt;/span&gt;

&lt;span class="x"&gt;            if poi.user.email:&lt;/span&gt;
&lt;span class="x"&gt;                message = render_to_string(&amp;quot;cms/points/email/approved.html&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;                    {&amp;quot;poi_name&amp;quot;: poi.name})&lt;/span&gt;
&lt;span class="x"&gt;                send_mail(&amp;quot;OUR CLIENT - Change Request Approved&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;                    message, settings.EMAIL_HOST_USER, [poi.user.email])&lt;/span&gt;

&lt;span class="x"&gt;    def _denied(self):&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        No way Jose&lt;/span&gt;
&lt;span class="x"&gt;        &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;
&lt;span class="x"&gt;        poi = self.get_object()&lt;/span&gt;
&lt;span class="x"&gt;        poi.status = 1&lt;/span&gt;
&lt;span class="x"&gt;        poi.approved_by = self.request.user&lt;/span&gt;
&lt;span class="x"&gt;        poi.approved_on = date.today()&lt;/span&gt;
&lt;span class="x"&gt;        poi.save()&lt;/span&gt;

&lt;span class="x"&gt;        messages.success(self.request,&lt;/span&gt;
&lt;span class="x"&gt;            &amp;quot;Point of interest &amp;#39;%s&amp;#39; has not been updated.&amp;quot; % poi.poi.name)&lt;/span&gt;

&lt;span class="x"&gt;        if poi.user.email:&lt;/span&gt;
&lt;span class="x"&gt;            message = render_to_string(&amp;quot;cms/points/email/denied.html&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;                {&amp;quot;poi_name&amp;quot;: poi.name})&lt;/span&gt;
&lt;span class="x"&gt;            send_mail(&amp;quot;OUR CLIENT - Change Request Denied&amp;quot;,&lt;/span&gt;
&lt;span class="x"&gt;                message, settings.EMAIL_HOST_USER, [poi.user.email])&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This view is really straightfoward. The editor clicks one of two buttons, both of which point to
this view. One contains a &lt;tt class="docutils literal"&gt;POST&lt;/tt&gt; variable indicating approval, the other indicating that the
change has been denied. Then, based on the value, we peform the same action on the &lt;tt class="docutils literal"&gt;POIChange&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;If the change was denied, we just set the status on the change to our denied flag, set the date
and user, and then save it.&lt;/p&gt;
&lt;p&gt;If it was approved, we create an instance of the &lt;tt class="docutils literal"&gt;POIForm&lt;/tt&gt; with the changed &lt;tt class="docutils literal"&gt;POI&lt;/tt&gt; as the
edited instance and our &lt;tt class="docutils literal"&gt;POIChange&lt;/tt&gt;'s &lt;tt class="docutils literal"&gt;__dict__&lt;/tt&gt; as the new data. Since they're copies of each
other, aside from the changes in the change model, of course, only the changed data really gets
updated. We make sure the form is still valid (some &lt;a class="reference external" href="http://geodjango.org"&gt;GeoDjango&lt;/a&gt; stuff I left out of the form above)
and then save the updated instance. We also update the &lt;tt class="docutils literal"&gt;POIChange&lt;/tt&gt; so it holds the new status,
the approving user and date.&lt;/p&gt;
&lt;p&gt;Regardless of the action taken, we send off an email to the user that submitted the change,
letting him or her know what happened.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;This has, so far, been a great workflow for our users. They're able to trust that the data going
out is verified and safe, but if anything gets out of date, we can change it ourselves or let the community of users tell us about the new data.&lt;/p&gt;
&lt;p&gt;There is a lot of stuff I didn't cover, what the &lt;tt class="docutils literal"&gt;Point&lt;/tt&gt; field holds on to, how to actually use GeoDjango, what each of our custom mixins does (we're planning on releasing these as a package soon), and lots of other
stuff. If you have questions/comments, hit us up on &lt;a class="reference external" href="http://twitter.com/brack3t"&gt;Twitter&lt;/a&gt;. Also, thanks to &lt;a class="reference external" href="http://pydanny.github.com"&gt;Daniel Greenfeld&lt;/a&gt; for a couple of edits.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="django"></category><category term="workflow"></category><category term="python"></category></entry><entry><title>Djangopeople.me</title><link href="http://brack3t.com/djangopeopleme.html" rel="alternate"></link><updated>2011-06-13T18:50:00Z</updated><author><name>Chris</name></author><id>tag:brack3t.com,2011-06-13:/djangopeopleme.html/</id><summary type="html">&lt;div class="section" id="what-is-it"&gt;
&lt;h2&gt;What is it?&lt;/h2&gt;
&lt;p&gt;At it's core, &lt;a class="reference external" href="http://djangopeople.me"&gt;djangopeople.me&lt;/a&gt; is a place for &lt;a class="reference external" href="https://www.djangoproject.com/"&gt;Django&lt;/a&gt; developers to register and be found based on their geographic location, whether it's by recruiters or a lonely Django developer like ourselves trying to find others close to him/her. That's the general idea behind the site.&lt;/p&gt;
&lt;p&gt;We wanted to make it clean, simple and fast. For the maps we ended up using &lt;a class="reference external" href="http://leaflet.cloudmade.com/"&gt;Leaflet's&lt;/a&gt; open-source Javascript library. We initially started with Google Maps, but the rate limiting was too restrictive on the geocoding API for our needs and frankly, loading maps seemed very slow. So, with the project being free-to-use (and us being cheap), we looked for something else.&lt;/p&gt;
&lt;p&gt;Yahoo! Maps was the next step as they had a decent API and allowed more requests. Google currently allows 2,500 requests per day and Yahoo allows 5,000 requests (geocoding). Yahoo's maps were faster to load but we seemed to have nothing but issues with &lt;a class="reference external" href="http://google.com/chrome"&gt;Google Chome&lt;/a&gt; throwing a YMAP Javascript error we could never track down. We didn't think it would be all that awesome telling Chrome users to clear their cache up to three times before the maps would load again (If you've had this issue and a have fix, for the love of all that is holy, let us know about it please).&lt;/p&gt;
&lt;p&gt;After searching around for a day, we came across &lt;a class="reference external" href="http://leaflet.cloudmade.com/"&gt;Leaflet&lt;/a&gt;. It was simple to implement and the maps were extremely fast to load compared to Google and Yahoo. You could also make the argument that they don't have nearly the traffic that Google and Yahoo have but Leaftlet was simple and it worked. Also, our scientific method for testing the load times was simply us reloading pages over and over as we worked on functionality. So don't expect any charts. Chris is an impatient guy, so if he gets annoyed by something he's built, it's not going live.&lt;/p&gt;
&lt;p&gt;There is one issue we ran into with Leaflet and it has yet to be resolved. Their geocoding API, after about two weeks of use, started retuning funky results. By funky I mean, resolving &lt;em&gt;Las Vegas, NV&lt;/em&gt;, to Livingston, Illinois. &lt;em&gt;Dallas, TX&lt;/em&gt; would come back as being in Australia. Chris emailed their support team and they have confirmed it is a bug but they do not have an idea of when it will be resolved. Aside from that, their service has been fantastic.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="it-s-already-been-done"&gt;
&lt;h2&gt;It's already been done.&lt;/h2&gt;
&lt;p&gt;This is true, &lt;a class="reference external" href="http://djangopeople.net"&gt;djangopeople.net&lt;/a&gt; was the inspiration for building djangopeople.me. We realized that djangopeople.net had been down for some time, intermittently. It was useful and we had both been contacted by people looking for Django developers through that site. So the original idea was to bring that functionality back and hopefully make it better.&lt;/p&gt;
&lt;p&gt;Kenneth came across a posting on &lt;a class="reference external" href="http://convore.com"&gt;Convore&lt;/a&gt; when we were almost ready to launch the site. It appeared that a group of developers were getting together to bring djangopeople.net back online. We almost stopped working on the site as dp.net came back online for a short time. It was really slow and then ended up going back down a day later. So we decided to finish the small bug fixes we were working on and launch it.&lt;/p&gt;
&lt;p&gt;So, just to be clear, djangopeople.me was inspired by &lt;a class="reference external" href="http://djangopeople.net"&gt;djangopeople.net&lt;/a&gt;. We just wanted to bring that back to the Python/Django community. We believe the interface is better and faster. Also, using &lt;a class="reference external" href="http://twitter.com"&gt;Twitter&lt;/a&gt; as the main auth system made it dead simple to sign up. We've had a few people ask for other authentication methods but at the moment Twitter provided exactly what we wanted with no hassle.&lt;/p&gt;
&lt;p&gt;We use your Twitter username so it's very easy to find a profile of someone you already know and follow. This also makes it a little difficult to add other authentication methods as we'll now have to deal with allowing people to choose usernames and possibly picking a Twitter username that a future developer would sign up with. We're open to suggestions but we like the simplicity of using Twitter. Having recently wrapped up a project using the &lt;a class="reference external" href="https://github.com/facebook/python-sdk"&gt;Facebook Python SDK&lt;/a&gt;, it was nice for Twitter's auth system to just work and not get in the way.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-s-next"&gt;
&lt;h2&gt;What's next?&lt;/h2&gt;
&lt;p&gt;We've had a good amount of people sign up and we've gotten some good feedback. We have a couple of
ideas for tying into other Django services but we're waiting for replies to our emails at the
moment. We both contract/freelance full time, so we'll probably spend the next week or two throwing
ideas around before we know what the next step is. In the meantime, check out the site and let us
know what you love and/or hate about it. We've got thick skins.&lt;/p&gt;
&lt;/div&gt;
</summary><category term="python"></category><category term="django"></category><category term="project"></category></entry></feed>